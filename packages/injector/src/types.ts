
/**
 * Class constructor type.
 * Fixme: This does not work for abstract classes.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type ClassType<T = any> = new (...params: any[]) => T;

/** Types that can be used as an injector token. */
export type InjectorToken<T = unknown> = symbol | string | number | ClassType<T> | Function;

/**
 * Factory of a binding that produces a value.
 *
 * @typeparam T Type of value produced by the factory.
 * @typeparam C Container type passed down to the factory.
 */
export type BindingFactory<T, C = Container> = (container: C) => T;

export interface ImmutableContainer {

  /**
   * Resolves a binding token
   *
   * @param token The token that should be resolved.
   * @returns The bindings resolved value.
   */
  get<T>(token: InjectorToken<T>): T;

  /**
   * Creates a new instance of the given class. If custom parameters are given
   * they replace the right side of the constructors parameter list.
   *
   * Todo: Examples.
   *
   * @param target A class from which an instance should be created.
   * @param params (optional) Custom parameters.
   * @param bind (optional) If set to true the newly created instance
   *  will also automatically be bound by calling {@link Container.instance}.
   * @returns Instance of the target with injected dependencies.
   */
  make<T = object>(target: ClassType<T>, params?: unknown[], bind?: boolean): T;

}

export interface Container extends ImmutableContainer {

  /**
   * Binds a value to a token.
   *
   * ### Example
   *
   * You can bind any kind of value to a valid {@link InjectorToken}. The most
   * common use case is to bind the instance of a class to its own type:
   *
   * ```typescript
   * container.bind(Foo, new Foo());
   *
   * // => true
   * console.log(container.get(Foo) instanceof Foo);
   * ```
   *
   * @param token The token to which the value is bound.
   * @param value The value that is bound to the given token.
   * @returns this
   */
  bind<T>(token: InjectorToken<T>, value: T): this;

  /**
   * Binds one or more instances to their own class type.
   *
   * ### Example
   *
   * ```typescript
   * container.instance(new Foo())
   *
   * // => true
   * console.log(container.get(Foo) instanceof Foo);
   * ```
   *
   * @param instances One or more instances.
   * @returns this
   */
  instance<T extends object>(...instances: T[]): this;

  /**
   * Binds a factory that should only be resolved once. Subsequent calls into
   * the container will return the initial value generated by the given factory.
   *
   * ### Example
   *
   * In the following example the factory is only called once, even though the
   * binding is resolved twice:
   *
   * ```typescript
   * // Last Id assigned to "Foo"
   * let lastId = 0;
   *
   * class Foo {
   *      constructor(public id: number) {}
   * }
   *
   * // Define a new singleton.
   * container.singleton(Foo, () => new Foo(++lastId));
   *
   * console.log(container.get(Foo).id); // => 1
   * console.log(container.get(Foo).id); // => 1
   * ```
   */
  singleton<T>(token: InjectorToken<T>, factory: BindingFactory<T>): this;

  /**
   * Binds a factory that is called every time the token is injected.
   *
   * ### Example
   *
   * ```ts
   * let counter = 0;
   *
   * container.factory('count', () => ++counter);
   *
   * @injectable()
   * class Foo {
   *      constructor(
   *          @inject('count') public number1: number,
   *          @inject('count') public number2: number
   *      ) {}
   * }
   *
   * const foo = container.make(Foo);
   *
   * console.log(foo.number1); // 1
   * console.log(foo.number2); // 2
   * ```
   *
   * @param token A binding token.
   * @param factory The factory that produces the value that is injected
   *  for the given token.
   * @returns this
   */
  factory<T>(token: InjectorToken<T>, factory: BindingFactory<T>): this;

  /**
   * Merges the given `container` into this one.
   *
   * ```ts
   * const a = new Container().bind('foo', true);
   * const b = new Container().bind('bar', true);
   *
   * a.merge(b);
   *
   * console.log(a.get('foo')) // true
   * console.log(a.get('bar')) // true
   * ```
   */
  merge(container: Container): this;

}

export interface Binding<T = unknown> {

  /**
   * Resolves the binding.
   *
   * @param container The container that attempts to resolve the binding.
   * @returns
   */
  resolve(container: Container): T;

}

export interface ParamInjection {
  /** The symbol that should be injected. */
  token: InjectorToken;
  /** The index of the parameter in the parameter list. */
  index: number;
  /** If `true` the container will pass `undefined` if a binding can not be resolved. */
  optional: boolean;
  /** The property key of the parameter. */
  key: string | symbol;
}


